---
title: "Suicide"
author: "René Mayer"
date: "02.06.2015"
output: pdf_document
---

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r}
library(foreign)
setwd('/home/rene/Dokumente/DirkRitter/')

s <- read.spss(file = "10 Suizidakten/Vgl. Suizid-Kontroll (incl. Daten).sav", 
   use.value.labels = TRUE,  # SPSS variables with value labels into R factors with levels
   max.value.labels = Inf,   # can be any real number 
      to.data.frame = TRUE,  # we want it to be an data.frame 
       use.missings = TRUE  # recode SPSS set missings-code to NA<
)

names(s)

#xqplot(s, ask=T)

library(mice)
library(VIM)

#md.pattern(s)

sg=s[,  !names(s) %in% c("Inhaft_Dat", "Dat_SPB", "Su_erhdat", "angekünd", "Absch_br", "Grund_Sui", "Beson_Sui", "angekünd", "Suizidvorgeschichte",
"Anz_SV", "SV_Wann", "Sui_1_Wo", "Suizidmeth_1", "Suizidmeth_2" , "Tt_WT", "Tt_Ft", "Tt_FT_WE", "TT_Jz", "Tz_Az", "Ergeb_GA", "Art_Erkrank2",
"SUR_1","SUR_2", "SUR_3", "SUR_4", "SUR_5", "SUR_6" , "Su_erhdat" , "Dat_SPB" , "Inhaft_Dat", "Nr","Code" ) ]


# Nr 51 fehlt - evtl. einlesefehler
aggr(sg[-51,], prop = F, numbers = T, cex.axis=.6)


sg=sg[-51,]
# skalennivau: kontinuierlich und faktoriel, nicht ordinal - das wird ein Fehler sin, aber der ist nicht so wichtig
( o=sapply( sg, class  ) )

# o[ order( o ) ]


d=md.pattern(sg)
d[8,]

sg$Mißbr_Such = factor(as.character(sg$Mißbr_Such))

# wir haben aufgrund der unterschiedlichen skalennivaus mixed data ... 
# Lösungen:   1. verwende polychorische cov [wieso nicht!, aber bedarf dummy coding aller factoren]
#		          2. FactoMineR kann mit mixed data umghen [vermtl. am leichtesten]
#		          3. cannonical correspondence analysis mit cca( . ~ gruppe, ...) [vermtl. am besten]

# setzte 2. im folgenden um
# FactoMineR
# install.packages('FactoMineR', dep=T)
library(FactoMineR)



# schneide alle Fragebogendaten weg, damit wir mit einem reien soziodemographischen Datensatz rechnenn können 
osg = sg[ , c(
 "Gruppe", 
 "JVA",  "Geschlecht", "Sprache", "National", 
 "Alter_Inh", "Alter_E", "Alt_Inhaft", "Alt_End",  
 "Familie", "Kind",  "Bezieh", "Besuche", 
 "Religion", "Schule", "Ausbild",
 "Haftart", "Arb_Haft", "Unterbri",  "Verh_Haft", 
 "Anz_Verl", "Dau_Inha", 
 "Indexdelikt", "Hafterfa", 
 "SPB",  "Erg_SPB", "Erg_zsfs", "Suizidversuche", "Arbeitstätigkeit", "kindheit", "PP_Auff", "GA_vorh", "Psych_Erk",  "Art_Erkrank", "Mißbr_Such", "Behandlung", "Raucher", "VISCI",
 "Anzahl_Erkr") ]
                                       
# > names(sg)[25]
# [1] "Gesamtst" - was soll das sein?

# wir mappen alle variablen auf variablengruppen und zwar so: 
d=
data.frame(group= c(1, 4, 4, 4, 3,4,  2, 2, 14, 1 ), 
          type= c("n", "n", "c", "n",  "n", "n",  "c",  "n",  "n",  "c"),
    name.group= c("suicide","demo", "time", "relations", "education", "haft", "delinq.c" , "delinq", "risk", "disorder.c"))
  
# ergiebt folgende zuordnung  
data.frame( d[rep(seq_len(nrow(d)), d$group),], 
            sapply(osg, class), names(sapply(osg, class)), 
            sapply(osg, function(x) length(levels(x))) )

require(missMDA)
completed <- imputeMFA(osg,ncp=2,
         group = c(1, 4, 4, 4, 3,4,  2, 2, 14, 1 ), 
          type = c("n", "n", "c", "n",  "n", "n",  "c",  "n",  "n",  "c"),
    name.group = c("suicide","demo", "time", "relations", "education", "haft", "delinq.c" , "delinq", "risk", "disorder.c"))
         




res <- MFA(osg, group= c(1, 4, 4, 4, 3,4,  2, 2, 14, 1 ), 
          type = c("n", "n", "c", "n",  "n", "n",  "c",  "n",  "n",  "c"),
    name.group = c("suicide","demo", "time", "relations", "education", "haft", "delinq.c" , "delinq", "risk", "disorder.c"),
         graph = FALSE, # bloß nicht, denn die plots sind nicht so schön
      tab.comp = completed
    )

# man sieht deulich, dass die Gruppenzugehörigkeitdurch die ersten beiden Dimensionen abgebildet wird    
summary(res)

# eigenwerte zerfallen negativ exponentiell für 30% der varianz in den Daten brauchen wir 5 Dimensionen
# aber wir wollen ja nicht die varianez dieses Datensatzes aufklären, sondern die Gruppenzugehörigkeit!
# barplot(res$eig[,1],main="Eigenvalues",names.arg=1:nrow(res$eig))

# xy-coordinaten, d.h. Ladungen für jede Dimension an den eigenwerten relativiert
coord = data.frame(res$ind$coord)

library(ggplot2)

ggplot(data = coord, aes(x = Dim.1, y = Dim.2, group=osg$Gruppe)) +
  geom_hline(yintercept = 0, colour = "gray70") +
  geom_vline(xintercept = 0, colour = "gray70") +
  geom_point(colour = "gray50", alpha = 0.7) +
  stat_density2d(geom="density2d", aes(color = osg$Gruppe,alpha=..level..),
                 size=1,
                 contour=TRUE)
                 

# zunächst die variablen-Gruppen
plot(res,choix="group",cex=2)

# welche skalen,, d.h.Ausprägungne (Dim.N) sind auf den Achsen gemappt?
# schutzfaktoren 'relations' vs. risikofaktoren bspw. 'Haft: 3', delinquenz dimension 1 scheint jedoch unabhängig von suizid zu sein
plot(res,choix="axes",habillage="group",palette=palette(),cex=.7)


# die kontinuierlichen variablen sind unabhängig von Suizid.
 plot(res,choix="var",habillage="group",palette=palette(),cex=.7)



```


Wenn wir die Achsen um 45° drehen können die Gruppen gut getrennt werden.
oder gleich eine logisitsche ?

evtl eine CCA, um denexplained variance zu bekommen?
ada4::discrimin